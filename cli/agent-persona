#!/usr/bin/env bash
#
# agent-persona - Agent persona management CLI (DEPRECATED: use 'agt persona' instead)
#
# Usage:
#   agt persona list                  # List available personas
#   agt persona install <persona>     # Install persona
#   agt persona install -g <persona>  # Install globally
#   agt persona review <persona>      # Code review with persona
#
# Legacy aliases (agent-persona) still work but are deprecated.
#

set -e

# 색상 정의
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
DIM='\033[2m'
NC='\033[0m'

# 스크립트 위치에서 agt 소스 디렉토리 찾기
find_source_dir() {
    local script_path="${BASH_SOURCE[0]}"

    # 심링크 해제
    while [[ -L "$script_path" ]]; do
        local link_target
        link_target=$(readlink "$script_path")
        if [[ "$link_target" == /* ]]; then
            script_path="$link_target"
        else
            script_path="$(dirname "$script_path")/$link_target"
        fi
    done

    # cli/ 디렉토리의 부모가 agt 소스
    local cli_dir
    cli_dir=$(cd "$(dirname "$script_path")" && pwd)
    echo "$(dirname "$cli_dir")"
}

SOURCE_DIR=$(find_source_dir)
PERSONA_LIB="${SOURCE_DIR}/personas"
GLOBAL_TARGET="${HOME}/.agents/personas"
LOCAL_TARGET=".agents/personas"

# 원격 설치 라이브러리 로드
REMOTE_LIB="$(dirname "${BASH_SOURCE[0]}")/lib/remote.sh"
[[ -f "$REMOTE_LIB" ]] && source "$REMOTE_LIB"

# 로그 함수
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

# 사용법
usage() {
    echo -e "\033[1;33m[DEPRECATED]\033[0m agent-persona is deprecated. Use 'agt persona' instead."
    echo ""
    cat << 'EOF'
agent-persona - Agent persona management (deprecated → agt persona)

Usage:
  agent-persona <command> [options] [arguments]

Commands:
  list                사용 가능한 페르소나 목록
  install <persona>   페르소나 설치 (기본: .agents/personas/)
  uninstall <persona> 페르소나 제거
  create <name>       새 페르소나 생성 (템플릿 기반)
  show <persona>      페르소나 내용 표시
  which <persona>     페르소나 소스 경로 확인
  review <persona>    페르소나로 현재 변경사항 리뷰

Install Options:
  -g, --global        전역 설치 (~/.agents/personas/)
  -f, --force         기존 페르소나 덮어쓰기
  --from SPEC         GitHub에서 원격 설치 (owner/repo/path[@ref])

List Options:
  --installed         설치된 페르소나만 표시
  --local             로컬 페르소나만
  --global            전역 페르소나만
  --json              JSON 형식 출력

Create Options:
  -g, --global              전역 생성 (~/.agents/personas/)
  --claude "DESCRIPTION"    Claude로 페르소나 생성
  --gemini "DESCRIPTION"    Gemini로 페르소나 생성
  --codex "DESCRIPTION"     Codex로 페르소나 생성
  --ollama "DESCRIPTION"    Ollama로 페르소나 생성
  --ai "DESCRIPTION"        자동 감지 LLM으로 생성 (codex>claude>gemini>ollama)
  --type TYPE               타입 지정 (review|planning|implementation, 기본: review)
  --role ROLE               역할 제목 지정
  --domain DOMAIN           도메인 지정

Review Options:
  --claude              Claude로 리뷰
  --gemini              Gemini로 리뷰
  --codex               Codex로 리뷰
  --ollama              Ollama로 리뷰
  --staged              staged 변경사항만 리뷰
  --base BRANCH         브랜치 기준 비교 리뷰
  -o, --output FILE     리뷰 결과를 파일로 저장

예시:
  agent-persona list                           # 전체 목록
  agent-persona install security-reviewer      # 로컬에 설치
  agent-persona install -g architecture-reviewer  # 전역에 설치
  agent-persona create my-reviewer             # 빈 템플릿으로 생성
  agent-persona create my-reviewer --gemini "senior Rust dev focused on memory safety"
  agent-persona create my-reviewer --claude "DBA with 15yr PostgreSQL optimization experience"
  agent-persona create my-reviewer --ai "auto-detect LLM and generate"
  agent-persona show security-reviewer         # 상세 보기
  agent-persona which security-reviewer        # 경로 확인
  agent-persona review security-reviewer       # 변경사항 리뷰 (LLM 자동감지)
  agent-persona review security-reviewer --gemini  # Gemini로 리뷰
  agent-persona review security-reviewer --staged  # staged만 리뷰
  agent-persona review security-reviewer -o review.md  # 파일로 저장

원격 설치:
  agent-persona install --from open330/agt/personas/security-reviewer
  agent-persona install -g --from open330/agt/personas/architecture-reviewer
  agent-persona install --from someone/their-repo/personas/my-reviewer@v1.0

페르소나 경로:
  로컬: .agents/personas/ (프로젝트)
  전역: ~/.agents/personas/ (사용자)

페르소나 우선순위:
  1. .agents/personas/ (프로젝트 로컬)
  2. ~/.agents/personas/ (전역)
  3. personas/ (라이브러리)

에이전트에서 직접 사용:
  페르소나는 일반 마크다운 파일이므로 어떤 AI 에이전트에서든 경로로 직접 참조 가능합니다.

  Claude Code:  "이 페르소나로 리뷰해줘: $(cat .agents/personas/security-reviewer.md)"
  Codex:        codex -p "Review with this persona: $(cat .agents/personas/security-reviewer.md)"
  Gemini:       cat .agents/personas/security-reviewer.md | gemini -p "Review current changes"
  CLAUDE.md:    에이전트 설정에 페르소나 경로를 포함시켜 자동 참조

EOF
    exit 0
}

# YAML frontmatter에서 필드 추출
get_frontmatter_field() {
    local file="$1"
    local field="$2"
    local max_len="${3:-}"

    [[ ! -f "$file" ]] && return

    local value
    value=$(sed -n '/^---$/,/^---$/p' "$file" | \
        grep -E "^${field}:" | \
        sed "s/^${field}:[[:space:]]*//" | \
        sed 's/^"\(.*\)"$/\1/' | \
        head -1)

    if [[ -n "$max_len" && -n "$value" && ${#value} -gt $max_len ]]; then
        value="${value:0:$((max_len - 3))}..."
    fi

    echo "$value"
}

# 라이브러리에서 페르소나 목록
get_library_personas() {
    [[ ! -d "$PERSONA_LIB" ]] && return

    for file in "${PERSONA_LIB}"/*.md; do
        [[ -f "$file" ]] || continue
        local filename
        filename=$(basename "$file" .md)
        [[ "$filename" == "README" ]] && continue

        # frontmatter에 name 필드가 있는지 확인
        local name
        name=$(get_frontmatter_field "$file" "name")
        [[ -n "$name" ]] && echo "$filename"
    done
}

# 설치된 페르소나 (로컬)
get_local_personas() {
    [[ ! -d "$LOCAL_TARGET" ]] && return

    for file in "${LOCAL_TARGET}"/*.md; do
        [[ -f "$file" ]] || continue
        local filename
        filename=$(basename "$file" .md)
        [[ "$filename" == "README" || "$filename" == "BRAND_CONTEXT" ]] && continue
        echo "$filename"
    done
}

# 설치된 페르소나 (전역)
get_global_personas() {
    [[ ! -d "$GLOBAL_TARGET" ]] && return

    for file in "${GLOBAL_TARGET}"/*.md; do
        [[ -f "$file" ]] || continue
        local filename
        filename=$(basename "$file" .md)
        [[ "$filename" == "README" ]] && continue
        echo "$filename"
    done
}

# 페르소나가 로컬에 설치되었는지 확인
is_installed_local() {
    local persona="$1"
    [[ -f "${LOCAL_TARGET}/${persona}.md" ]]
}

# 페르소나가 전역에 설치되었는지 확인
is_installed_global() {
    local persona="$1"
    [[ -f "${GLOBAL_TARGET}/${persona}.md" ]]
}

# 페르소나 파일 경로 찾기 (우선순위: 로컬 > 전역 > 라이브러리)
find_persona_path() {
    local name="$1"

    # .md 확장자 제거 (있는 경우)
    name="${name%.md}"

    # 로컬
    if [[ -f "${LOCAL_TARGET}/${name}.md" ]]; then
        echo "${LOCAL_TARGET}/${name}.md"
        return 0
    fi

    # 전역
    if [[ -f "${GLOBAL_TARGET}/${name}.md" ]]; then
        echo "${GLOBAL_TARGET}/${name}.md"
        return 0
    fi

    # 라이브러리
    if [[ -f "${PERSONA_LIB}/${name}.md" ]]; then
        echo "${PERSONA_LIB}/${name}.md"
        return 0
    fi

    return 1
}

# 원격 페르소나 설치
install_remote_persona() {
    local spec="$1"
    local target_dir="$2"
    local force="$3"

    if ! parse_remote_spec "$spec"; then
        return 1
    fi

    log_info "원격 다운로드: ${REMOTE_OWNER}/${REMOTE_REPO}/${REMOTE_PATH}@${REMOTE_REF}"

    # 페르소나 이름 추출 (.md 제거)
    local persona_name
    persona_name=$(basename "$REMOTE_PATH" .md)
    local target_path="${target_dir}/${persona_name}.md"

    # 이미 존재하는 경우
    if [[ -e "$target_path" ]]; then
        if [[ "$force" == "true" ]]; then
            log_warn "덮어쓰기: ${persona_name}.md"
            rm -f "$target_path"
            rm -f "${target_dir}/${persona_name}.remote-source"
        else
            log_warn "이미 설치됨 (스킵): ${persona_name}.md (-f로 덮어쓰기)"
            return 0
        fi
    fi

    # 빠른 경로: raw URL로 단일 파일 다운로드
    local remote_file_path="${REMOTE_PATH}"
    [[ "$remote_file_path" != *.md ]] && remote_file_path="${remote_file_path}.md"

    if fetch_remote_file "$REMOTE_OWNER" "$REMOTE_REPO" "$remote_file_path" "$REMOTE_REF" > "$target_path" 2>/dev/null; then
        # frontmatter 검증
        if head -1 "$target_path" | grep -q "^---"; then
            write_remote_metadata "$target_path" "$spec" "$REMOTE_REF"
            log_success "설치됨 (원격): ${persona_name}.md ← ${REMOTE_OWNER}/${REMOTE_REPO}"
            return 0
        fi
    fi

    # 실패 시 정리
    rm -f "$target_path"
    log_error "페르소나 다운로드 실패: $spec"
    return 1
}

# install 명령
cmd_install() {
    local global=false
    local force=false
    local remote_spec=""
    local targets=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -g|--global) global=true; shift ;;
            -f|--force) force=true; shift ;;
            --from) remote_spec="$2"; shift 2 ;;
            -*) log_error "알 수 없는 옵션: $1"; exit 1 ;;
            *) targets+=("$1"); shift ;;
        esac
    done

    # 원격 설치 또는 로컬 설치 중 하나는 필요
    if [[ -z "$remote_spec" && ${#targets[@]} -eq 0 ]]; then
        log_error "설치할 페르소나를 지정하세요"
        echo "예: agent-persona install security-reviewer"
        echo "    agent-persona install --from owner/repo/personas/name"
        echo ""
        echo "사용 가능한 페르소나:"
        for p in $(get_library_personas); do
            echo "  $p"
        done
        exit 1
    fi

    # 대상 디렉토리 설정
    local target_dir
    if [[ "$global" == "true" ]]; then
        target_dir="$GLOBAL_TARGET"
        log_info "전역 설치: $target_dir"
    else
        target_dir="$LOCAL_TARGET"
        log_info "로컬 설치: $(pwd)/$target_dir"
    fi

    mkdir -p "$target_dir"

    local installed=0
    local failed=0

    # 원격 설치
    if [[ -n "$remote_spec" ]]; then
        install_remote_persona "$remote_spec" "$target_dir" "$force" && \
            installed=$((installed + 1)) || \
            failed=$((failed + 1))

        echo ""
        if [[ $installed -gt 0 ]]; then
            log_success "$installed 개 페르소나 설치됨"
        fi
        if [[ $failed -gt 0 ]]; then
            log_warn "$failed 개 페르소나 설치 실패"
            exit 1
        fi
        return
    fi

    for target in "${targets[@]}"; do
        local name="${target%.md}"
        local source_path="${PERSONA_LIB}/${name}.md"

        if [[ ! -f "$source_path" ]]; then
            log_error "페르소나를 찾을 수 없습니다: $name"
            log_info "사용 가능: $(get_library_personas | tr '\n' ' ')"
            failed=$((failed + 1))
            continue
        fi

        local target_path="${target_dir}/${name}.md"

        if [[ -e "$target_path" ]]; then
            if [[ "$force" == "true" ]]; then
                log_warn "덮어쓰기: ${name}.md"
                rm -f "$target_path"
            else
                log_warn "이미 설치됨 (스킵): ${name}.md (-f로 덮어쓰기)"
                continue
            fi
        fi

        ln -s "$source_path" "$target_path"
        log_success "설치됨: ${name}.md"
        installed=$((installed + 1))
    done

    echo ""
    if [[ $installed -gt 0 ]]; then
        log_success "$installed 개 페르소나 설치됨"
    fi
    if [[ $failed -gt 0 ]]; then
        log_warn "$failed 개 페르소나 설치 실패"
        exit 1
    fi
}

# uninstall 명령
cmd_uninstall() {
    local global=false
    local targets=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -g|--global) global=true; shift ;;
            -*) log_error "알 수 없는 옵션: $1"; exit 1 ;;
            *) targets+=("$1"); shift ;;
        esac
    done

    if [[ ${#targets[@]} -eq 0 ]]; then
        log_error "제거할 페르소나를 지정하세요"
        exit 1
    fi

    local target_dir
    if [[ "$global" == "true" ]]; then
        target_dir="$GLOBAL_TARGET"
    else
        target_dir="$LOCAL_TARGET"
    fi

    local removed=0

    for target in "${targets[@]}"; do
        local name="${target%.md}"
        local persona_path="${target_dir}/${name}.md"

        if [[ -e "$persona_path" ]]; then
            rm -f "$persona_path"
            log_success "제거됨: ${name}.md"
            removed=$((removed + 1))
        else
            log_warn "설치되지 않음: ${name}.md"
        fi
    done

    [[ $removed -gt 0 ]] && log_info "$removed 개 페르소나 제거됨"
}

# AI 생성용 시스템 프롬프트
get_ai_system_prompt() {
    cat << 'SYSPROMPT'
You are an expert at creating detailed agent persona definitions for code review and software engineering tasks.

Generate a persona markdown file with YAML frontmatter. The persona should feel like a real person with genuine expertise — specific tools they use, specific past experiences, strong opinions, and clear evaluation criteria.

## Required Format

```
---
name: kebab-case-id
role: "Human-Readable Role Title"
domain: one-word-domain
type: review|planning|implementation
tags: [relevant, tags, here]
---

# Persona Title

## Identity
Detailed background as a real person: years of experience, certifications, specific companies/projects, tools used daily. Make them feel authentic.

### Background
- **Primary expertise**: specific areas
- **Languages**: languages they can review
- **Tools daily**: specific tools they use
- **Past experience**: concrete examples

### Attitude
How they approach reviews — their personality, biases, what they care most about.

## Review Lens
5-7 numbered focus areas with specific questions they ask.

## Evaluation Framework
Table with Category | Severity (CRITICAL/HIGH/MEDIUM/LOW) | Criteria columns.
At least 8-10 rows covering the domain thoroughly.

## Output Format
Markdown template showing exactly how findings should be structured.

## Red Flags
10+ specific patterns/anti-patterns that must always be flagged. Be very specific (actual code patterns, not vague descriptions).

## Key Principles
5-7 core beliefs that guide this persona's reviews.
```

IMPORTANT:
- Output ONLY the markdown file content (starting with ---). No explanations, no wrapping.
- Make the persona deeply knowledgeable — not generic. Include specific tools, frameworks, metrics, and real-world examples.
- The persona should have strong opinions and a clear personality.
- Red flags should be concrete and actionable (actual code patterns like `eval()`, not vague like "bad practices").
SYSPROMPT
}

# 이름을 파일명 안전한 kebab-case로 변환
sanitize_name() {
    local input="$1"
    echo "$input" | \
        tr '[:upper:]' '[:lower:]' | \
        sed 's/[[:space:]]/-/g' | \
        sed 's/[^a-z0-9가-힣ㄱ-ㅎㅏ-ㅣ_-]/-/g' | \
        sed 's/-\{2,\}/-/g' | \
        sed 's/^-//;s/-$//'
}

# 사용 가능한 LLM CLI 감지 (우선순위: codex > claude > gemini > ollama)
detect_llm_cli() {
    if command -v codex &>/dev/null; then
        echo "codex"
    # claude는 Claude Code 내부에서 실행 불가 — CLAUDECODE 환경변수로 감지
    elif [[ -z "${CLAUDECODE:-}" ]] && command -v claude &>/dev/null; then
        echo "claude"
    elif command -v gemini &>/dev/null; then
        echo "gemini"
    elif command -v ollama &>/dev/null; then
        echo "ollama"
    else
        echo ""
    fi
}

# LLM으로 페르소나 생성
# 정리할 임시 파일 추적
_CLEANUP_FILES=()

_cleanup() {
    for f in "${_CLEANUP_FILES[@]}"; do
        rm -f "$f" 2>/dev/null
    done
    _CLEANUP_FILES=()
    echo "" # Ctrl+C 후 줄바꿈
    log_warn "중단됨"
    exit 130
}

generate_with_llm() {
    local llm_cli="$1"
    local name="$2"
    local description="$3"
    local persona_type="$4"
    local target_file="$5"

    local system_prompt
    system_prompt=$(get_ai_system_prompt)

    # 프롬프트를 임시 파일에 저장 (쉘 인자 길이/특수문자 문제 방지)
    local prompt_file
    prompt_file=$(mktemp "${TMPDIR:-/tmp}/persona-prompt-$$-XXXXXXXXXX")

    # Ctrl+C 시 임시 파일 + 미완성 출력 파일 정리
    _CLEANUP_FILES=("$prompt_file" "$target_file")
    trap _cleanup INT TERM

    cat > "$prompt_file" << PROMPT_EOF
${system_prompt}

---

Create a ${persona_type} persona named '${name}'.

Description: ${description}

Use the exact markdown format specified above. The persona should be deeply specific to the described role. Output ONLY the markdown content starting with ---.
PROMPT_EOF

    log_info "LLM으로 생성 중... (${llm_cli}) — Ctrl+C로 취소"

    local exit_code=0

    case "$llm_cli" in
        claude)
            claude -p "$(cat "$prompt_file")" --output-format text > "$target_file" 2>/dev/null || exit_code=$?
            ;;
        gemini)
            # gemini: stdin으로 프롬프트 전달, -p로 지시 추가
            cat "$prompt_file" | gemini -p "Follow the instructions from stdin. Output ONLY raw markdown starting with ---. No code fences." -o text > "$target_file" 2>/dev/null || exit_code=$?
            ;;
        codex)
            codex exec --full-auto "$(cat "$prompt_file")" > "$target_file" 2>/dev/null || exit_code=$?
            ;;
        ollama)
            cat "$prompt_file" | ollama run llama3.2 > "$target_file" 2>/dev/null || exit_code=$?
            ;;
    esac

    # 정상 완료 — trap 해제, 임시 파일 정리
    trap - INT TERM
    _CLEANUP_FILES=()
    rm -f "$prompt_file"
    return $exit_code
}

# 페르소나 요약 출력
show_persona_summary() {
    local file="$1"
    [[ ! -f "$file" ]] && return

    local name role domain ptype tags
    name=$(get_frontmatter_field "$file" "name")
    role=$(get_frontmatter_field "$file" "role")
    domain=$(get_frontmatter_field "$file" "domain")
    ptype=$(get_frontmatter_field "$file" "type")
    tags=$(get_frontmatter_field "$file" "tags")

    echo ""
    echo -e "${CYAN}── Persona Summary ──────────────────────${NC}"
    echo -e "  ${DIM}Name${NC}     ${name:-?}"
    echo -e "  ${DIM}Role${NC}     ${role:-?}"
    echo -e "  ${DIM}Domain${NC}   ${domain:-?}"
    echo -e "  ${DIM}Type${NC}     ${ptype:-?}"
    [[ -n "$tags" ]] && echo -e "  ${DIM}Tags${NC}     ${tags}"

    # 섹션 헤딩 추출 (## 로 시작하는 라인)
    local sections
    sections=$(sed -n '/^## /s/^## //p' "$file" | head -8)
    if [[ -n "$sections" ]]; then
        echo -e "  ${DIM}Sections${NC}"
        while IFS= read -r section; do
            echo -e "    ${GREEN}•${NC} ${section}"
        done <<< "$sections"
    fi
    echo -e "${CYAN}─────────────────────────────────────────${NC}"
    echo ""
}

# LLM CLI 사용 가능 여부 확인
check_llm_available() {
    local llm="$1"
    case "$llm" in
        claude)
            # Claude Code 내부에서는 실행 불가
            [[ -z "${CLAUDECODE:-}" ]] && command -v claude &>/dev/null
            ;;
        *)
            command -v "$llm" &>/dev/null
            ;;
    esac
}

# create 명령
cmd_create() {
    local global=false
    local persona_type="review"
    local role=""
    local domain=""
    local ai_description=""
    local ai_llm=""  # 명시적 LLM 선택 (빈 문자열이면 auto-detect)
    local name=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -g|--global) global=true; shift ;;
            --type) persona_type="$2"; shift 2 ;;
            --role) role="$2"; shift 2 ;;
            --domain) domain="$2"; shift 2 ;;
            --claude)  ai_llm="claude";  ai_description="$2"; shift 2 ;;
            --gemini)  ai_llm="gemini";  ai_description="$2"; shift 2 ;;
            --codex)   ai_llm="codex";   ai_description="$2"; shift 2 ;;
            --ollama)  ai_llm="ollama";  ai_description="$2"; shift 2 ;;
            --ai)      ai_llm="auto";    ai_description="$2"; shift 2 ;;
            -*) log_error "알 수 없는 옵션: $1"; exit 1 ;;
            *) name="$1"; shift ;;
        esac
    done

    if [[ -z "$name" ]]; then
        log_error "페르소나 이름을 지정하세요"
        echo "예: agent-persona create my-reviewer"
        echo "예: agent-persona create my-reviewer --gemini \"senior Rust dev focused on memory safety\""
        exit 1
    fi

    # 표시 이름 보존, 파일명은 sanitize
    local display_name="$name"
    local file_name
    file_name=$(sanitize_name "$name")

    if [[ -z "$file_name" ]]; then
        log_error "유효한 파일명을 생성할 수 없습니다: $name"
        exit 1
    fi

    if [[ "$file_name" != "$name" ]]; then
        log_info "파일명: ${file_name}.md (원본: ${display_name})"
    fi

    # 대상 디렉토리
    local target_dir
    if [[ "$global" == "true" ]]; then
        target_dir="$GLOBAL_TARGET"
    else
        target_dir="$LOCAL_TARGET"
    fi

    mkdir -p "$target_dir"

    local target_file="${target_dir}/${file_name}.md"

    if [[ -e "$target_file" ]]; then
        log_error "이미 존재합니다: $target_file"
        log_info "삭제 후 다시 시도하세요: rm $target_file"
        exit 1
    fi

    # AI 생성 모드
    if [[ -n "$ai_description" ]]; then
        local llm_cli=""

        if [[ "$ai_llm" == "auto" ]]; then
            # 자동 감지
            llm_cli=$(detect_llm_cli)
        else
            # 명시적 선택 — 사용 가능 여부 확인
            if check_llm_available "$ai_llm"; then
                llm_cli="$ai_llm"
            else
                log_error "${ai_llm} CLI를 찾을 수 없습니다"
                if [[ "$ai_llm" == "claude" && -n "${CLAUDECODE:-}" ]]; then
                    log_info "Claude Code 내부에서는 claude CLI를 사용할 수 없습니다"
                    log_info "대안: --gemini, --codex, --ollama, --ai (자동 감지)"
                fi
                exit 1
            fi
        fi

        if [[ -z "$llm_cli" ]]; then
            log_error "사용 가능한 LLM CLI가 없습니다 (claude, gemini, codex, ollama)"
            log_info "수동 템플릿으로 대체합니다..."
            ai_description=""  # fallback to template
        else
            if generate_with_llm "$llm_cli" "$file_name" "$ai_description" "$persona_type" "$target_file"; then
                # 생성된 파일 검증
                if [[ -s "$target_file" ]] && head -1 "$target_file" | grep -q "^---"; then
                    log_success "AI 생성 완료: $target_file (by ${llm_cli})"
                    show_persona_summary "$target_file"
                    return 0
                else
                    log_warn "AI 생성 결과가 올바르지 않습니다. 템플릿으로 대체합니다..."
                    rm -f "$target_file"
                    ai_description=""  # fallback to template
                fi
            else
                log_warn "AI 생성 실패. 템플릿으로 대체합니다..."
                rm -f "$target_file"
                ai_description=""  # fallback to template
            fi
        fi
    fi

    # 기본값 (템플릿 모드)
    [[ -z "$role" ]] && role="Reviewer"
    [[ -z "$domain" ]] && domain="general"

    # 템플릿 생성
    cat > "$target_file" << EOF
---
name: ${file_name}
role: "${role}"
domain: ${domain}
type: ${persona_type}
tags: []
---

# ${display_name}

## Identity

You are a **[role description]** with [N]+ years of experience in [domain].

### Background

- **Primary expertise**: [areas of expertise]
- **Languages**: [languages you can review]
- **Past experience**: [relevant experience]

### Attitude

[How this persona approaches reviews — skeptical? pragmatic? empathetic?]

## Review Lens

When reviewing code, you focus on:

1. **[Focus area 1]**: [What you look for]
2. **[Focus area 2]**: [What you look for]
3. **[Focus area 3]**: [What you look for]

## Evaluation Framework

| Category | Severity | Criteria |
|----------|----------|----------|
| **[Category 1]** | CRITICAL | [What triggers this] |
| **[Category 2]** | HIGH | [What triggers this] |
| **[Category 3]** | MEDIUM | [What triggers this] |

## Output Format

\`\`\`markdown
## Review by ${display_name}

### Summary
- **Assessment**: [overall assessment]
- **Findings**: N total

### Findings

#### [SEVERITY] Finding Title
- **File**: \`path/to/file:line\`
- **Issue**: [description]
- **Recommendation**: [fix suggestion]
\`\`\`

## Red Flags

- [Pattern that must always be flagged]
- [Pattern that must always be flagged]

## Key Principles

1. [Core principle]
2. [Core principle]
3. [Core principle]
EOF

    log_success "생성됨: $target_file"
    show_persona_summary "$target_file"
    log_info "편집하세요: $target_file"
}

# show 명령
cmd_show() {
    local name="$1"

    if [[ -z "$name" ]]; then
        log_error "페르소나 이름을 지정하세요"
        exit 1
    fi

    local path
    if ! path=$(find_persona_path "$name"); then
        log_error "페르소나를 찾을 수 없습니다: $name"
        exit 1
    fi

    # 위치 표시
    local scope="라이브러리"
    if [[ "$path" == "${LOCAL_TARGET}/"* ]]; then
        scope="로컬"
    elif [[ "$path" == "${GLOBAL_TARGET}/"* ]]; then
        scope="전역"
    fi

    echo -e "${DIM}# 위치: ${path} (${scope})${NC}"
    echo ""
    cat "$path"
}

# which 명령
cmd_which() {
    local name="$1"

    if [[ -z "$name" ]]; then
        log_error "페르소나 이름을 지정하세요"
        exit 1
    fi

    local path
    if ! path=$(find_persona_path "$name"); then
        log_error "페르소나를 찾을 수 없습니다: $name"
        exit 1
    fi

    # 심링크인 경우 실제 경로도 표시
    if [[ -L "$path" ]]; then
        local real_path
        real_path=$(readlink -f "$path" 2>/dev/null || readlink "$path")
        echo "$path -> $real_path"
    else
        echo "$path"
    fi

    # 원격 설치 메타데이터 표시
    local remote_file="${path%.md}.remote-source"
    if [[ -f "$remote_file" ]]; then
        echo ""
        log_info "원격 설치:"
        cat "$remote_file"
    fi
}

# list 명령
cmd_list() {
    local show_installed=false
    local show_local=false
    local show_global=false
    local json_output=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --installed) show_installed=true; shift ;;
            --local) show_local=true; shift ;;
            --global) show_global=true; shift ;;
            --json) json_output=true; shift ;;
            -*) log_error "알 수 없는 옵션: $1"; exit 1 ;;
            *) shift ;;
        esac
    done

    # 설치된 페르소나만
    if [[ "$show_installed" == "true" ]]; then
        list_installed "$show_local" "$show_global" "$json_output"
        return
    fi

    # 전체 목록
    list_all "$json_output"
}

# 설치된 페르소나 목록
list_installed() {
    local show_local="$1"
    local show_global="$2"
    local json_output="$3"

    local local_list=()
    local global_list=()

    if [[ "$show_global" != "true" ]]; then
        while IFS= read -r p; do
            [[ -n "$p" ]] && local_list+=("$p")
        done < <(get_local_personas)
    fi

    if [[ "$show_local" != "true" ]]; then
        while IFS= read -r p; do
            [[ -n "$p" ]] && global_list+=("$p")
        done < <(get_global_personas)
    fi

    if [[ "$json_output" == "true" ]]; then
        echo "{"
        echo -n "  \"local\": ["
        local first=true
        for p in "${local_list[@]}"; do
            [[ "$first" == "true" ]] && first=false || echo -n ","
            echo -n "\"$p\""
        done
        echo "],"
        echo -n "  \"global\": ["
        first=true
        for p in "${global_list[@]}"; do
            [[ "$first" == "true" ]] && first=false || echo -n ","
            echo -n "\"$p\""
        done
        echo "]"
        echo "}"
        return
    fi

    echo ""
    echo -e "${CYAN}설치된 페르소나${NC}"
    echo "========================================"

    if [[ "$show_global" != "true" && ${#local_list[@]} -gt 0 ]]; then
        echo -e "\n${YELLOW}로컬${NC} (.agents/personas/) - ${#local_list[@]}개"
        for p in "${local_list[@]}"; do
            local role
            role=$(get_frontmatter_field "${LOCAL_TARGET}/${p}.md" "role" 40)
            printf "  ${GREEN}✓${NC} %-28s %s\n" "$p" "${role:-}"
        done
    fi

    if [[ "$show_local" != "true" && ${#global_list[@]} -gt 0 ]]; then
        echo -e "\n${YELLOW}전역${NC} (~/.agents/personas/) - ${#global_list[@]}개"
        for p in "${global_list[@]}"; do
            local role
            role=$(get_frontmatter_field "${GLOBAL_TARGET}/${p}.md" "role" 40)
            printf "  ${GREEN}✓${NC} %-28s %s\n" "$p" "${role:-}"
        done
    fi

    if [[ ${#local_list[@]} -eq 0 && ${#global_list[@]} -eq 0 ]]; then
        echo ""
        echo "  설치된 페르소나가 없습니다"
        echo ""
        echo "  설치 예시: agent-persona install security-reviewer"
    fi

    echo ""
}

# 전체 목록 (라이브러리 기준, 설치 상태 표시)
list_all() {
    local json_output="$1"

    # 라이브러리 페르소나 수집
    local personas=()
    while IFS= read -r p; do
        [[ -n "$p" ]] && personas+=("$p")
    done < <(get_library_personas)

    # 로컬 전용 페르소나 (라이브러리에 없는 것)
    local local_only=()
    while IFS= read -r p; do
        [[ -z "$p" ]] && continue
        local in_lib=false
        for lp in "${personas[@]}"; do
            [[ "$lp" == "$p" ]] && { in_lib=true; break; }
        done
        [[ "$in_lib" == "false" ]] && local_only+=("$p")
    done < <(get_local_personas)

    # 전역 전용 페르소나
    local global_only=()
    while IFS= read -r p; do
        [[ -z "$p" ]] && continue
        local in_lib=false
        for lp in "${personas[@]}"; do
            [[ "$lp" == "$p" ]] && { in_lib=true; break; }
        done
        local in_local=false
        for lo in "${local_only[@]}"; do
            [[ "$lo" == "$p" ]] && { in_local=true; break; }
        done
        [[ "$in_lib" == "false" && "$in_local" == "false" ]] && global_only+=("$p")
    done < <(get_global_personas)

    if [[ "$json_output" == "true" ]]; then
        echo "{"
        echo "  \"library\": ["
        local first=true
        for p in "${personas[@]}"; do
            [[ "$first" == "true" ]] && first=false || echo ","
            local status="available"
            is_installed_local "$p" && status="local"
            is_installed_global "$p" && status="global"
            echo -n "    {\"name\":\"$p\",\"status\":\"$status\"}"
        done
        echo ""
        echo "  ],"
        local lo_json=""
        if [[ ${#local_only[@]} -gt 0 ]]; then
            lo_json=$(printf '"%s",' "${local_only[@]}" | sed 's/,$//')
        fi
        local go_json=""
        if [[ ${#global_only[@]} -gt 0 ]]; then
            go_json=$(printf '"%s",' "${global_only[@]}" | sed 's/,$//')
        fi
        echo "  \"local_only\": [${lo_json}],"
        echo "  \"global_only\": [${go_json}]"
        echo "}"
        return
    fi

    echo ""
    echo -e "${CYAN}사용 가능한 페르소나${NC}  (${GREEN}L${NC}=로컬 ${BLUE}G${NC}=전역 ${DIM}○${NC}=미설치)"
    echo "========================================"

    local total=0
    local installed_count=0

    # 타입별 그룹핑
    local current_type=""
    for p in "${personas[@]}"; do
        local source_file="${PERSONA_LIB}/${p}.md"
        local ptype
        ptype=$(get_frontmatter_field "$source_file" "type")
        local role
        role=$(get_frontmatter_field "$source_file" "role" 40)

        # 타입 헤더
        if [[ "$ptype" != "$current_type" ]]; then
            current_type="$ptype"
            echo -e "\n${YELLOW}${current_type:-unknown}/${NC}"
        fi

        # 설치 상태
        local icon="${DIM}○${NC}"
        if is_installed_local "$p"; then
            icon="${GREEN}L${NC}"
            installed_count=$((installed_count + 1))
        elif is_installed_global "$p"; then
            icon="${BLUE}G${NC}"
            installed_count=$((installed_count + 1))
        fi

        printf "  %b %-28s %s\n" "$icon" "$p" "${role:-}"
        total=$((total + 1))
    done

    # 로컬 전용
    if [[ ${#local_only[@]} -gt 0 ]]; then
        echo -e "\n${YELLOW}로컬 전용${NC} (.agents/personas/)"
        for p in "${local_only[@]}"; do
            local role
            role=$(get_frontmatter_field "${LOCAL_TARGET}/${p}.md" "role" 40)
            printf "  ${GREEN}L${NC} %-28s %s\n" "$p" "${role:-}"
            total=$((total + 1))
            installed_count=$((installed_count + 1))
        done
    fi

    # 전역 전용
    if [[ ${#global_only[@]} -gt 0 ]]; then
        echo -e "\n${YELLOW}전역 전용${NC} (~/.agents/personas/)"
        for p in "${global_only[@]}"; do
            local role
            role=$(get_frontmatter_field "${GLOBAL_TARGET}/${p}.md" "role" 40)
            printf "  ${BLUE}G${NC} %-28s %s\n" "$p" "${role:-}"
            total=$((total + 1))
            installed_count=$((installed_count + 1))
        done
    fi

    echo ""
    echo -e "${CYAN}요약${NC}: 전체 ${total}개 / 설치됨 ${installed_count}개"
    echo ""
    echo "설치 예시:"
    echo "  agent-persona install security-reviewer       # 로컬"
    echo "  agent-persona install -g architecture-reviewer # 전역"
    echo "  agent-persona create my-reviewer              # 새로 만들기"
    echo ""
}

# 메인
# review 명령
cmd_review() {
    local persona_name=""
    local llm_cli=""
    local ai_llm=""
    local staged_only=false
    local output_file=""
    local base_branch=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            --claude)  ai_llm="claude";  shift ;;
            --gemini)  ai_llm="gemini";  shift ;;
            --codex)   ai_llm="codex";   shift ;;
            --ollama)  ai_llm="ollama";  shift ;;
            --staged)  staged_only=true;  shift ;;
            --base)    base_branch="$2";  shift 2 ;;
            -o|--output) output_file="$2"; shift 2 ;;
            -*) log_error "알 수 없는 옵션: $1"; exit 1 ;;
            *) persona_name="$1"; shift ;;
        esac
    done

    if [[ -z "$persona_name" ]]; then
        log_error "페르소나 이름을 지정하세요"
        echo ""
        echo "사용법: agent-persona review <persona> [options]"
        echo ""
        echo "예시:"
        echo "  agent-persona review security-reviewer"
        echo "  agent-persona review security-reviewer --gemini"
        echo "  agent-persona review security-reviewer --staged"
        echo "  agent-persona review security-reviewer --base main"
        echo "  agent-persona review security-reviewer -o review.md"
        exit 1
    fi

    # 페르소나 파일 찾기
    local persona_path
    if ! persona_path=$(find_persona_path "$persona_name"); then
        log_error "페르소나를 찾을 수 없습니다: $persona_name"
        log_info "사용 가능: agent-persona list"
        exit 1
    fi

    local persona_content
    persona_content=$(cat "$persona_path")

    # git diff 수집
    if ! command -v git &>/dev/null; then
        log_error "git을 찾을 수 없습니다"
        exit 1
    fi

    if ! git rev-parse --is-inside-work-tree &>/dev/null 2>&1; then
        log_error "git 저장소가 아닙니다"
        exit 1
    fi

    local diff_content=""
    local diff_desc=""

    if [[ -n "$base_branch" ]]; then
        # 브랜치 비교
        diff_content=$(git diff "$base_branch"...HEAD 2>/dev/null)
        diff_desc="changes vs ${base_branch}"
    elif [[ "$staged_only" == "true" ]]; then
        # staged만
        diff_content=$(git diff --cached 2>/dev/null)
        diff_desc="staged changes"
    else
        # staged + unstaged 전체
        diff_content=$(git diff HEAD 2>/dev/null)
        # HEAD가 없는 경우 (첫 커밋 전) staged만
        if [[ -z "$diff_content" ]]; then
            diff_content=$(git diff --cached 2>/dev/null)
        fi
        # unstaged만이라도
        if [[ -z "$diff_content" ]]; then
            diff_content=$(git diff 2>/dev/null)
        fi
        diff_desc="all uncommitted changes"
    fi

    if [[ -z "$diff_content" ]]; then
        log_warn "리뷰할 변경사항이 없습니다"
        log_info "확인: git status"
        exit 0
    fi

    # diff 통계
    local files_changed lines_added lines_removed
    files_changed=$(echo "$diff_content" | grep -c '^diff --git' || true)
    lines_added=$(echo "$diff_content" | grep -c '^+[^+]' || true)
    lines_removed=$(echo "$diff_content" | grep -c '^-[^-]' || true)

    local role
    role=$(get_frontmatter_field "$persona_path" "role")

    log_info "페르소나: ${persona_name} (${role:-?})"
    log_info "대상: ${diff_desc} (${files_changed} files, +${lines_added} -${lines_removed})"

    # LLM 선택
    if [[ -n "$ai_llm" ]]; then
        if check_llm_available "$ai_llm"; then
            llm_cli="$ai_llm"
        else
            log_error "${ai_llm} CLI를 찾을 수 없습니다"
            if [[ "$ai_llm" == "claude" && -n "${CLAUDECODE:-}" ]]; then
                log_info "Claude Code 내부에서는 claude CLI를 사용할 수 없습니다"
            fi
            exit 1
        fi
    else
        llm_cli=$(detect_llm_cli)
    fi

    if [[ -z "$llm_cli" ]]; then
        log_error "사용 가능한 LLM CLI가 없습니다 (claude, gemini, codex, ollama)"
        exit 1
    fi

    # 리뷰 프롬프트 구성
    local prompt_file
    prompt_file=$(mktemp "${TMPDIR:-/tmp}/persona-review-$$-XXXXXXXXXX")

    cat > "$prompt_file" << REVIEW_EOF
You are adopting the following persona for this code review. Read the persona definition carefully and review the code changes strictly from this persona's perspective, using the evaluation framework and output format defined in the persona.

## Persona Definition

${persona_content}

---

## Code Changes to Review

The following is a git diff of ${diff_desc}:

\`\`\`diff
${diff_content}
\`\`\`

---

## Instructions

1. Adopt the persona above completely
2. Review the code changes using the persona's Review Lens and Evaluation Framework
3. Output your review using the persona's Output Format
4. Be specific — reference file paths and line numbers from the diff
5. Prioritize findings by severity as defined in the Evaluation Framework
REVIEW_EOF

    # Ctrl+C 핸들링
    _CLEANUP_FILES=("$prompt_file")
    trap _cleanup INT TERM

    log_info "리뷰 중... (${llm_cli}) — Ctrl+C로 취소"
    echo ""

    local exit_code=0
    local review_output=""

    case "$llm_cli" in
        claude)
            review_output=$(claude -p "$(cat "$prompt_file")" --output-format text 2>/dev/null) || exit_code=$?
            ;;
        gemini)
            review_output=$(cat "$prompt_file" | gemini -p "Follow the review instructions from stdin. Output the review in markdown." -o text 2>/dev/null) || exit_code=$?
            ;;
        codex)
            review_output=$(codex exec --full-auto "$(cat "$prompt_file")" 2>/dev/null) || exit_code=$?
            ;;
        ollama)
            review_output=$(cat "$prompt_file" | ollama run llama3.2 2>/dev/null) || exit_code=$?
            ;;
    esac

    # trap 해제 및 정리
    trap - INT TERM
    _CLEANUP_FILES=()
    rm -f "$prompt_file"

    if [[ $exit_code -ne 0 || -z "$review_output" ]]; then
        log_error "리뷰 생성 실패 (${llm_cli}, exit: ${exit_code})"
        exit 1
    fi

    # 출력
    if [[ -n "$output_file" ]]; then
        echo "$review_output" > "$output_file"
        log_success "리뷰 저장됨: $output_file"
        echo ""
        # 요약만 표시 (첫 20줄)
        head -20 "$output_file"
        local total_lines
        total_lines=$(wc -l < "$output_file" | tr -d ' ')
        if [[ $total_lines -gt 20 ]]; then
            echo ""
            echo -e "${DIM}... (${total_lines} lines total, see ${output_file})${NC}"
        fi
    else
        echo "$review_output"
    fi
}

# 메인
main() {
    if [[ $# -eq 0 ]]; then
        usage
    fi

    local command="$1"
    shift

    case "$command" in
        install)    cmd_install "$@" ;;
        uninstall)  cmd_uninstall "$@" ;;
        list)       cmd_list "$@" ;;
        create)     cmd_create "$@" ;;
        show)       cmd_show "$@" ;;
        which)      cmd_which "$@" ;;
        review)     cmd_review "$@" ;;
        -h|--help|help) usage ;;
        *)
            log_error "알 수 없는 명령: $command"
            echo "사용법: agent-persona --help"
            exit 1
            ;;
    esac
}

main "$@"
