#!/usr/bin/env python3
"""
claude-skill - Run Claude skills from CLI (DEPRECATED: use 'agt run' instead)

Usage:
    agt run "natural language prompt"
    agt run --skill git-commit-pr "commit this"
    agt skill list

Legacy usage (still works but deprecated):
    claude-skill "보안 검사해줘"
    claude-skill --skill security-auditor "scan"
    claude-skill --list
"""

import argparse
import json
import os
import re
import subprocess
import sys
from pathlib import Path
from typing import Optional

# 색상 코드
class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    MAGENTA = "\033[35m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"

    @classmethod
    def disable(cls):
        """색상 비활성화"""
        for attr in ["RESET", "BOLD", "DIM", "RED", "GREEN", "YELLOW", "BLUE", "MAGENTA", "CYAN", "WHITE"]:
            setattr(cls, attr, "")


# 제외 디렉토리 (스킬 그룹으로 인식하지 않음)
EXCLUDE_DIRS = {"static", "cli", ".git", ".github", ".agents", "node_modules", "__pycache__"}


def get_skills_dir() -> Path:
    """설치된 스킬 디렉토리 반환"""
    return Path.home() / ".claude" / "skills"


def get_agent_skills_dir() -> Path:
    """agent-skills 소스 디렉토리 반환"""
    script_dir = Path(__file__).resolve().parent.parent
    return script_dir


def extract_overview(content: str) -> Optional[str]:
    """본문에서 Overview 섹션 추출"""
    # YAML frontmatter 제거
    content = re.sub(r'^---\s*\n.*?\n---\s*\n?', '', content, flags=re.DOTALL)

    # ## Overview 섹션 찾기
    overview_match = re.search(
        r'##\s*Overview\s*\n+(.*?)(?=\n##|\Z)',
        content,
        re.IGNORECASE | re.DOTALL
    )

    if overview_match:
        overview = overview_match.group(1).strip()
        # 첫 2-3 문단만 추출
        paragraphs = [p.strip() for p in overview.split('\n\n') if p.strip()]
        if paragraphs:
            result = '\n\n'.join(paragraphs[:2])
            if len(result) > 500:
                result = result[:500] + "..."
            return result
    return None


def extract_when_to_use(content: str) -> Optional[str]:
    """본문에서 When to Use 섹션 추출"""
    content = re.sub(r'^---\s*\n.*?\n---\s*\n?', '', content, flags=re.DOTALL)

    when_match = re.search(
        r'##\s*When\s+to\s+Use\s*\n+(.*?)(?=\n##|\Z)',
        content,
        re.IGNORECASE | re.DOTALL
    )

    if when_match:
        when_text = when_match.group(1).strip()
        if len(when_text) > 300:
            when_text = when_text[:300] + "..."
        return when_text
    return None


def load_skill_metadata(skill_path: Path, verbose: bool = False) -> dict:
    """SKILL.md에서 메타데이터 추출"""
    skill_md = skill_path / "SKILL.md"
    if not skill_md.exists():
        return {}

    content = skill_md.read_text(encoding="utf-8")

    # YAML frontmatter 파싱
    match = re.match(r'^---\s*\n(.*?)\n---', content, re.DOTALL)
    if not match:
        return {"content": content}

    frontmatter = match.group(1)
    metadata = {"content": content}

    # name 추출
    name_match = re.search(r'^name:\s*(.+)$', frontmatter, re.MULTILINE)
    if name_match:
        metadata["name"] = name_match.group(1).strip()

    # description 추출
    desc_match = re.search(r'^description:\s*(.+?)(?:\n(?!\s)|\Z)', frontmatter, re.MULTILINE | re.DOTALL)
    if desc_match:
        metadata["description"] = desc_match.group(1).strip().split('\n')[0]

    # trigger_keywords 추출
    keywords_match = re.search(r'^trigger_keywords:\s*\n((?:\s+-\s*.+\n?)+)', frontmatter, re.MULTILINE)
    if keywords_match:
        keywords_text = keywords_match.group(1)
        keywords = re.findall(r'-\s*(.+)', keywords_text)
        metadata["keywords"] = [k.strip() for k in keywords]

    # verbose 모드일 때 추가 정보 추출
    if verbose:
        overview = extract_overview(content)
        if overview:
            metadata["overview"] = overview
        when_to_use = extract_when_to_use(content)
        if when_to_use:
            metadata["when_to_use"] = when_to_use

    return metadata


def list_installed_skills(verbose: bool = False) -> list[dict]:
    """설치된 스킬 목록 반환"""
    skills_dir = get_skills_dir()
    if not skills_dir.exists():
        return []

    skills = []
    for skill_path in sorted(skills_dir.iterdir()):
        if skill_path.is_dir() or skill_path.is_symlink():
            actual_path = skill_path.resolve() if skill_path.is_symlink() else skill_path
            if (actual_path / "SKILL.md").exists():
                metadata = load_skill_metadata(actual_path, verbose=verbose)
                info = {
                    "name": skill_path.name,
                    "path": str(actual_path),
                    "is_symlink": skill_path.is_symlink(),
                }
                if skill_path.is_symlink():
                    info["link_target"] = str(actual_path)
                    # 그룹 추출
                    parts = actual_path.parts
                    if len(parts) >= 2:
                        info["group"] = parts[-2]
                info.update(metadata)
                skills.append(info)

    return skills


def get_source_skills(verbose: bool = False) -> dict:
    """소스 디렉토리의 모든 스킬 (그룹별)"""
    source_dir = get_agent_skills_dir()
    groups = {}

    for group_dir in sorted(source_dir.iterdir()):
        if not group_dir.is_dir():
            continue
        if group_dir.name in EXCLUDE_DIRS or group_dir.name.startswith('.'):
            continue

        skills = []
        for skill_dir in sorted(group_dir.iterdir()):
            if skill_dir.is_dir() and (skill_dir / "SKILL.md").exists():
                info = load_skill_metadata(skill_dir, verbose=verbose)
                if info:
                    info["group"] = group_dir.name
                    info["path"] = str(skill_dir)
                    skills.append(info)

        if skills:
            groups[group_dir.name] = skills

    return groups


def build_skill_index(skills: list[dict]) -> str:
    """Claude에게 전달할 스킬 인덱스 생성"""
    lines = ["사용 가능한 스킬 목록:", ""]

    for skill in sorted(skills, key=lambda x: x.get("name", "")):
        name = skill.get("name", "unknown")
        desc = skill.get("description", "(설명 없음)")
        lines.append(f"- **{name}**: {desc}")

    return "\n".join(lines)


def print_skills_list(args: argparse.Namespace):
    """스킬 목록 출력 (옵션에 따라 다른 형식)"""
    verbose = args.verbose
    show_all = args.all
    output_json = args.json
    output_plain = args.plain

    # 색상 비활성화 (파이프 또는 json/plain)
    if output_json or output_plain or not sys.stdout.isatty():
        Colors.disable()

    # 데이터 수집
    installed_skills = list_installed_skills(verbose=verbose)
    installed_names = {s.get("name", "") for s in installed_skills}

    if show_all:
        source_groups = get_source_skills(verbose=verbose)
    else:
        source_groups = None

    # JSON 출력
    if output_json:
        # content 필드 제거 (너무 큼)
        def clean_skill(s):
            return {k: v for k, v in s.items() if k != "content"}

        if show_all:
            cleaned_groups = {
                group: [clean_skill(s) for s in skills]
                for group, skills in source_groups.items()
            }
            output = {
                "groups": cleaned_groups,
                "installed": list(installed_names),
                "total_skills": sum(len(skills) for skills in source_groups.values()),
                "installed_count": len(installed_names)
            }
        else:
            output = {
                "skills": [clean_skill(s) for s in installed_skills],
                "count": len(installed_skills)
            }
        print(json.dumps(output, ensure_ascii=False, indent=2))
        return

    # Plain 출력 (스킬 이름만)
    if output_plain:
        if show_all:
            for group, skills in source_groups.items():
                for skill in skills:
                    print(skill.get("name", ""))
        else:
            for skill in installed_skills:
                print(skill.get("name", ""))
        return

    # 포맷된 출력
    if show_all:
        _print_source_skills(source_groups, verbose, installed_names)
    else:
        _print_installed_skills(installed_skills, verbose)


def _print_installed_skills(skills: list[dict], verbose: bool):
    """설치된 스킬 목록 출력"""
    print(f"\n{Colors.CYAN}설치된 스킬{Colors.RESET} ({len(skills)}개)")
    print("=" * 60)

    for skill in skills:
        name = skill.get("name", "unknown")
        desc = skill.get("description", "(설명 없음)")
        group = skill.get("group", "")

        print(f"\n{Colors.GREEN}{name}{Colors.RESET}")
        if group:
            print(f"  {Colors.DIM}[{group}]{Colors.RESET}")

        if not verbose:
            desc = desc[:60] + "..." if len(desc) > 60 else desc
        print(f"  {desc}")

        if verbose:
            if skill.get("overview"):
                print(f"\n  {Colors.YELLOW}Overview:{Colors.RESET}")
                for line in skill["overview"].split('\n'):
                    print(f"    {line}")

            if skill.get("when_to_use"):
                print(f"\n  {Colors.YELLOW}When to Use:{Colors.RESET}")
                for line in skill["when_to_use"].split('\n'):
                    print(f"    {Colors.DIM}{line}{Colors.RESET}")

            if skill.get("keywords"):
                kw = ", ".join(skill["keywords"][:10])
                print(f"\n  {Colors.BLUE}Keywords:{Colors.RESET} {kw}")

    print()


def _print_source_skills(groups: dict, verbose: bool, installed_names: set):
    """소스의 모든 스킬 출력 (그룹별)"""
    total = sum(len(skills) for skills in groups.values())
    installed_count = len(installed_names)

    print(f"\n{Colors.CYAN}사용 가능한 스킬{Colors.RESET}  ({Colors.GREEN}✓{Colors.RESET} 설치됨 / {Colors.RED}○{Colors.RESET} 미설치)")
    print("=" * 60)
    print(f"전체 {total}개 / 설치됨 {installed_count}개")

    for group, skills in groups.items():
        group_installed = sum(1 for s in skills if s.get("name") in installed_names)
        print(f"\n{Colors.YELLOW}{group}/{Colors.RESET} ({group_installed}/{len(skills)})")

        for skill in skills:
            name = skill.get("name", "unknown")
            desc = skill.get("description", "(설명 없음)")
            is_installed = name in installed_names

            if is_installed:
                icon = f"{Colors.GREEN}✓{Colors.RESET}"
                name_display = f"{Colors.GREEN}{name}{Colors.RESET}"
            else:
                icon = f"{Colors.RED}○{Colors.RESET}"
                name_display = name

            if not verbose:
                desc = desc[:40] + "..." if len(desc) > 40 else desc
                print(f"  {icon} {name:<24} {Colors.DIM}{desc}{Colors.RESET}")
            else:
                print(f"  {icon} {name_display}")
                print(f"     {desc}")

                if skill.get("overview"):
                    print(f"\n     {Colors.YELLOW}Overview:{Colors.RESET}")
                    for line in skill["overview"].split('\n')[:5]:
                        print(f"       {Colors.DIM}{line}{Colors.RESET}")

                if skill.get("keywords"):
                    kw = ", ".join(skill["keywords"][:8])
                    print(f"\n     {Colors.BLUE}Keywords:{Colors.RESET} {kw}")

                print()

    print()


def run_claude_with_skill(prompt: str, skill: Optional[dict], skills: list[dict], args: argparse.Namespace):
    """Claude CLI 실행"""

    cmd = ["claude", "-p"]

    # 스트리밍 모드 (stream-json은 --verbose 필요)
    if not args.no_stream:
        cmd.extend(["--verbose", "--output-format", "stream-json"])

    # 시스템 프롬프트 구성
    if skill:
        # 스킬이 직접 지정된 경우
        skill_content = skill.get("content", "")
        skill_name = skill.get("name", "unknown")

        system_prompt = f"""당신은 '{skill_name}' 스킬을 사용하여 작업을 수행합니다.

다음은 스킬 문서입니다:

{skill_content}

위 스킬의 Workflow를 따라 작업을 수행하세요.
진행 상황을 단계별로 알려주세요."""

    elif not args.no_skill and skills:
        # Claude가 스킬을 선택하도록 함 (인덱스만 전달하여 크기 제한)
        skill_index = build_skill_index(skills)

        # 키워드 정보 추가
        keywords_info = []
        for s in skills:
            name = s.get("name", "unknown")
            keywords = s.get("keywords", [])
            if keywords:
                keywords_info.append(f"- {name}: {', '.join(keywords[:5])}")

        keywords_section = ""
        if keywords_info:
            keywords_section = "\n\n## 스킬 키워드\n" + "\n".join(keywords_info)

        system_prompt = f"""당신은 사용자의 요청에 가장 적합한 스킬을 선택하여 작업을 수행합니다.

{skill_index}{keywords_section}

## 지침

1. 사용자 요청을 분석하여 가장 적합한 스킬을 선택하세요.
2. 선택한 스킬 이름을 응답 첫 줄에 명시: "[스킬: 스킬이름]" 또는 "[스킬: 없음]"
3. 스킬을 선택했다면 해당 스킬의 역할에 맞게 작업을 수행하세요.
4. 적합한 스킬이 없으면 일반적인 방식으로 작업을 수행하세요.
"""
    else:
        system_prompt = None

    if system_prompt:
        cmd.extend(["--append-system-prompt", system_prompt])

    # 권한 모드 (기본: bypassPermissions, --interactive로 권한 요청 모드)
    if not args.interactive:
        cmd.extend(["--permission-mode", "bypassPermissions"])

    # 프롬프트 추가
    cmd.append(prompt)

    # 실행
    if args.verbose:
        print(f"{Colors.DIM}실행: {' '.join(cmd[:5])}...{Colors.RESET}\n")

    if args.no_stream:
        # 일반 모드
        result = subprocess.run(cmd, capture_output=True, text=True)
        print(result.stdout)
        if result.stderr:
            print(f"{Colors.RED}{result.stderr}{Colors.RESET}", file=sys.stderr)
        return result.returncode
    else:
        # 스트리밍 모드
        return run_streaming(cmd, args)


def run_streaming(cmd: list[str], args: argparse.Namespace) -> int:
    """스트리밍 모드로 실행"""
    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        bufsize=1
    )

    current_tool = None
    tool_count = 0
    collected_text = []  # result_only 모드용 텍스트 수집

    try:
        for line in process.stdout:
            line = line.strip()
            if not line:
                continue

            try:
                data = json.loads(line)
            except json.JSONDecodeError:
                continue

            msg_type = data.get("type")

            if msg_type == "assistant":
                # 어시스턴트 메시지
                message = data.get("message", {})
                content = message.get("content", [])

                for block in content:
                    if block.get("type") == "text":
                        text = block.get("text", "")
                        if text:
                            if args.result_only:
                                collected_text.append(text)
                            else:
                                print(text, end="", flush=True)
                    elif block.get("type") == "tool_use":
                        tool_name = block.get("name", "unknown")
                        tool_count += 1
                        current_tool = tool_name

                        # 도구 사용 시작 표시 (result_only 모드에서는 숨김)
                        if args.result_only:
                            pass
                        elif args.verbose:
                            print(f"\n{Colors.BLUE}[{tool_count}] {tool_name}{Colors.RESET}", end="", flush=True)
                            tool_input = block.get("input", {})
                            if tool_name == "Bash":
                                cmd_str = tool_input.get("command", "")[:60]
                                print(f" {Colors.DIM}{cmd_str}{Colors.RESET}", flush=True)
                            elif tool_name in ("Read", "Write", "Edit"):
                                file_path = tool_input.get("file_path", "")
                                print(f" {Colors.DIM}{file_path}{Colors.RESET}", flush=True)
                            else:
                                print(flush=True)
                        else:
                            # 간단한 진행 표시
                            print(f"{Colors.DIM}.{Colors.RESET}", end="", flush=True)

            elif msg_type == "result":
                # 최종 결과
                result = data.get("result", "")

                if args.result_only:
                    # result_only 모드: 수집된 텍스트 또는 result 출력
                    if collected_text:
                        print("".join(collected_text))
                    elif result:
                        print(result)
                else:
                    if result:
                        print(f"\n\n{Colors.GREEN}━━━ 결과 ━━━{Colors.RESET}")
                        print(result)

                # 통계
                cost_usd = data.get("total_cost_usd", 0)
                duration_ms = data.get("duration_ms", 0)
                duration_sec = duration_ms / 1000

                # 토큰 사용량
                usage = data.get("usage", {})
                input_tokens = usage.get("input_tokens", 0)
                output_tokens = usage.get("output_tokens", 0)
                cache_read = usage.get("cache_read_input_tokens", 0)
                total_tokens = input_tokens + output_tokens + cache_read

                print(f"\n{Colors.DIM}[도구: {tool_count}회 | 토큰: {total_tokens:,} | 소요: {duration_sec:.1f}s | 비용: ${cost_usd:.4f}]{Colors.RESET}")

            elif msg_type == "error":
                error_msg = data.get("error", {}).get("message", "Unknown error")
                print(f"\n{Colors.RED}오류: {error_msg}{Colors.RESET}", file=sys.stderr)

    except KeyboardInterrupt:
        process.terminate()
        print(f"\n{Colors.YELLOW}중단됨{Colors.RESET}")
        return 130

    process.wait()
    return process.returncode


def main():
    parser = argparse.ArgumentParser(
        description="Claude 스킬을 CLI에서 직접 실행",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
예시:
  claude-skill "보안 검사해줘"
  claude-skill --skill git-commit-pr "커밋해줘"
  claude-skill -y "콜라보 서버 띄워줘"
  claude-skill --list
  claude-skill --list --verbose          # 상세 설명 포함
  claude-skill --list --all              # 소스의 모든 스킬 (설치 여부 표시)
  claude-skill --list --json             # JSON 출력
  claude-skill --list --plain            # 스킬 이름만 (파이프용)
        """
    )

    parser.add_argument("prompt", nargs="?", help="실행할 자연어 명령")
    parser.add_argument("-s", "--skill", help="사용할 스킬 이름 직접 지정")
    parser.add_argument("-l", "--list", action="store_true", help="스킬 목록 출력")
    parser.add_argument("-a", "--all", action="store_true", help="소스의 모든 스킬 표시 (--list와 함께 사용)")
    parser.add_argument("-i", "--interactive", action="store_true", help="권한 요청 모드 (기본: 자동 승인)")
    parser.add_argument("-v", "--verbose", action="store_true", help="상세 출력 (Overview, When to Use 포함)")
    parser.add_argument("-j", "--json", action="store_true", help="JSON 출력 (--list와 함께 사용)")
    parser.add_argument("-p", "--plain", action="store_true", help="스킬 이름만 출력 (--list와 함께 사용)")
    parser.add_argument("-r", "--result-only", action="store_true", help="최종 결과만 출력 (스트리밍 숨김)")
    parser.add_argument("--no-stream", action="store_true", help="스트리밍 비활성화")
    parser.add_argument("--no-skill", action="store_true", help="스킬 매칭 없이 실행")

    args = parser.parse_args()

    # 스킬 목록 모드
    if args.list:
        print_skills_list(args)
        return 0

    # 스킬 목록
    skills = list_installed_skills()

    if not args.prompt:
        parser.print_help()
        return 1

    # 스킬 선택
    skill = None

    if args.no_skill:
        # 스킬 없이 실행
        pass
    elif args.skill:
        # 직접 지정된 스킬
        for s in skills:
            if s.get("name") == args.skill:
                skill = s
                break

        if not skill:
            print(f"{Colors.RED}스킬을 찾을 수 없습니다: {args.skill}{Colors.RESET}")
            print(f"{Colors.DIM}설치된 스킬: {', '.join(s.get('name', '') for s in skills)}{Colors.RESET}")
            return 1

    # 헤더 출력 (result_only 모드에서는 숨김)
    if not args.result_only:
        print(f"\n{Colors.CYAN}━━━ Claude Skill ━━━{Colors.RESET}")
        if skill:
            print(f"{Colors.GREEN}스킬:{Colors.RESET} {skill.get('name')}")
            print(f"{Colors.DIM}{skill.get('description', '')[:60]}{Colors.RESET}")
        elif args.no_skill:
            print(f"{Colors.DIM}스킬 비활성화 (일반 모드){Colors.RESET}")
        else:
            print(f"{Colors.YELLOW}스킬:{Colors.RESET} Claude가 자동 선택")
            print(f"{Colors.DIM}설치된 스킬 {len(skills)}개 중에서 적합한 스킬을 선택합니다{Colors.RESET}")
        print(f"{Colors.GREEN}명령:{Colors.RESET} {args.prompt}")
        print()

    # 실행
    return run_claude_with_skill(args.prompt, skill, skills, args)


if __name__ == "__main__":
    sys.exit(main())
